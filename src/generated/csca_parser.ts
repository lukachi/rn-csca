// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
} from './csca_parser-ffi';
import {
  type UniffiByteArray,
  AbstractFfiConverterByteArray,
  FfiConverterArray,
  FfiConverterArrayBuffer,
  FfiConverterBool,
  FfiConverterInt32,
  FfiConverterOptional,
  RustBuffer,
  UniffiError,
  UniffiInternalError,
  UniffiRustCaller,
  uniffiCreateFfiConverterString,
  uniffiTypeNameSymbol,
  variantOrdinalSymbol,
} from 'uniffi-bindgen-react-native';

// Get converters from the other files, if any.
const uniffiCaller = new UniffiRustCaller(() => ({ code: 0 }));

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== 'object' ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== 'production' ||
  false;
// Public interface members begin here.

/**
 * Find the master certificate for a given slave certificate
 * Returns the DER data of the master certificate if found
 */
export function findMasterCertificate(
  slaveCertDer: ArrayBuffer,
  masterCertsDer: Array<ArrayBuffer>
): ArrayBuffer | undefined /*throws*/ {
  return FfiConverterOptionalArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCscaError.lift.bind(
        FfiConverterTypeCscaError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_csca_parser_fn_func_find_master_certificate(
          FfiConverterArrayBuffer.lower(slaveCertDer),
          FfiConverterArrayArrayBuffer.lower(masterCertsDer),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Parse LDIF bytes and return raw certificate DER data
 * This function returns a vector of raw certificate bytes (DER format)
 * suitable for parsing with tools like peculiar/asn1-schema
 */
export function parseLdif(data: ArrayBuffer): Array<ArrayBuffer> /*throws*/ {
  return FfiConverterArrayArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCscaError.lift.bind(
        FfiConverterTypeCscaError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_csca_parser_fn_func_parse_ldif(
          FfiConverterArrayBuffer.lower(data),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Parse LDIF string and return raw certificate DER data
 * This function returns a vector of raw certificate bytes (DER format)
 * suitable for parsing with tools like peculiar/asn1-schema
 */
export function parseLdifString(data: string): Array<ArrayBuffer> /*throws*/ {
  return FfiConverterArrayArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCscaError.lift.bind(
        FfiConverterTypeCscaError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_csca_parser_fn_func_parse_ldif_string(
          FfiConverterString.lower(data),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Parse PEM bytes and return raw certificate DER data
 * This function returns a vector of raw certificate bytes (DER format)
 * suitable for parsing with tools like peculiar/asn1-schema
 */
export function parsePem(data: ArrayBuffer): Array<ArrayBuffer> /*throws*/ {
  return FfiConverterArrayArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCscaError.lift.bind(
        FfiConverterTypeCscaError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_csca_parser_fn_func_parse_pem(
          FfiConverterArrayBuffer.lower(data),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Parse PEM string and return raw certificate DER data
 * This function returns a vector of raw certificate bytes (DER format)
 * suitable for parsing with tools like peculiar/asn1-schema
 */
export function parsePemString(data: string): Array<ArrayBuffer> /*throws*/ {
  return FfiConverterArrayArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCscaError.lift.bind(
        FfiConverterTypeCscaError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_csca_parser_fn_func_parse_pem_string(
          FfiConverterString.lower(data),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}

const stringConverter = {
  stringToBytes: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
        s,
        status
      )
    ),
  bytesToString: (ab: UniffiByteArray) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
        ab,
        status
      )
    ),
  stringByteLength: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(
        s,
        status
      )
    ),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

// Flat error type: CscaError
export enum CscaError_Tags {
  LdifParseError = 'LdifParseError',
  CertificateError = 'CertificateError',
  InvalidFormat = 'InvalidFormat',
  NoCertificatesFound = 'NoCertificatesFound',
  Base64Error = 'Base64Error',
  Utf8Error = 'Utf8Error',
  Asn1Error = 'Asn1Error',
  DerError = 'DerError',
  X509Error = 'X509Error',
  PemError = 'PemError',
}
export const CscaError = (() => {
  class LdifParseError extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'CscaError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = CscaError_Tags.LdifParseError;

    constructor(message: string) {
      super('CscaError', 'LdifParseError', message);
    }

    static instanceOf(e: any): e is LdifParseError {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }
  class CertificateError extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'CscaError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 2;

    public readonly tag = CscaError_Tags.CertificateError;

    constructor(message: string) {
      super('CscaError', 'CertificateError', message);
    }

    static instanceOf(e: any): e is CertificateError {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 2;
    }
  }
  class InvalidFormat extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'CscaError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 3;

    public readonly tag = CscaError_Tags.InvalidFormat;

    constructor(message: string) {
      super('CscaError', 'InvalidFormat', message);
    }

    static instanceOf(e: any): e is InvalidFormat {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 3;
    }
  }
  class NoCertificatesFound extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'CscaError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 4;

    public readonly tag = CscaError_Tags.NoCertificatesFound;

    constructor(message: string) {
      super('CscaError', 'NoCertificatesFound', message);
    }

    static instanceOf(e: any): e is NoCertificatesFound {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 4;
    }
  }
  class Base64Error extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'CscaError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 5;

    public readonly tag = CscaError_Tags.Base64Error;

    constructor(message: string) {
      super('CscaError', 'Base64Error', message);
    }

    static instanceOf(e: any): e is Base64Error {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 5;
    }
  }
  class Utf8Error extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'CscaError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 6;

    public readonly tag = CscaError_Tags.Utf8Error;

    constructor(message: string) {
      super('CscaError', 'Utf8Error', message);
    }

    static instanceOf(e: any): e is Utf8Error {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 6;
    }
  }
  class Asn1Error extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'CscaError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 7;

    public readonly tag = CscaError_Tags.Asn1Error;

    constructor(message: string) {
      super('CscaError', 'Asn1Error', message);
    }

    static instanceOf(e: any): e is Asn1Error {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 7;
    }
  }
  class DerError extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'CscaError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 8;

    public readonly tag = CscaError_Tags.DerError;

    constructor(message: string) {
      super('CscaError', 'DerError', message);
    }

    static instanceOf(e: any): e is DerError {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 8;
    }
  }
  class X509Error extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'CscaError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 9;

    public readonly tag = CscaError_Tags.X509Error;

    constructor(message: string) {
      super('CscaError', 'X509Error', message);
    }

    static instanceOf(e: any): e is X509Error {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 9;
    }
  }
  class PemError extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'CscaError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 10;

    public readonly tag = CscaError_Tags.PemError;

    constructor(message: string) {
      super('CscaError', 'PemError', message);
    }

    static instanceOf(e: any): e is PemError {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 10;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is CscaError {
    return (e as any)[uniffiTypeNameSymbol] === 'CscaError';
  }
  return {
    LdifParseError,
    CertificateError,
    InvalidFormat,
    NoCertificatesFound,
    Base64Error,
    Utf8Error,
    Asn1Error,
    DerError,
    X509Error,
    PemError,
    instanceOf,
  };
})();

// Union type for CscaError error type.

export type CscaError = InstanceType<
  (typeof CscaError)[keyof Omit<typeof CscaError, 'instanceOf'>]
>;

const FfiConverterTypeCscaError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = CscaError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new CscaError.LdifParseError(FfiConverterString.read(from));

        case 2:
          return new CscaError.CertificateError(FfiConverterString.read(from));

        case 3:
          return new CscaError.InvalidFormat(FfiConverterString.read(from));

        case 4:
          return new CscaError.NoCertificatesFound(
            FfiConverterString.read(from)
          );

        case 5:
          return new CscaError.Base64Error(FfiConverterString.read(from));

        case 6:
          return new CscaError.Utf8Error(FfiConverterString.read(from));

        case 7:
          return new CscaError.Asn1Error(FfiConverterString.read(from));

        case 8:
          return new CscaError.DerError(FfiConverterString.read(from));

        case 9:
          return new CscaError.X509Error(FfiConverterString.read(from));

        case 10:
          return new CscaError.PemError(FfiConverterString.read(from));

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

// FfiConverter for ArrayBuffer | undefined
const FfiConverterOptionalArrayBuffer = new FfiConverterOptional(
  FfiConverterArrayBuffer
);

// FfiConverter for Array<ArrayBuffer>
const FfiConverterArrayArrayBuffer = new FfiConverterArray(
  FfiConverterArrayBuffer
);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 29;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ubrn_ffi_csca_parser_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion
    );
  }
  if (
    nativeModule().ubrn_uniffi_csca_parser_checksum_func_find_master_certificate() !==
    38924
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_csca_parser_checksum_func_find_master_certificate'
    );
  }
  if (
    nativeModule().ubrn_uniffi_csca_parser_checksum_func_parse_ldif() !== 31974
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_csca_parser_checksum_func_parse_ldif'
    );
  }
  if (
    nativeModule().ubrn_uniffi_csca_parser_checksum_func_parse_ldif_string() !==
    39072
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_csca_parser_checksum_func_parse_ldif_string'
    );
  }
  if (
    nativeModule().ubrn_uniffi_csca_parser_checksum_func_parse_pem() !== 26888
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_csca_parser_checksum_func_parse_pem'
    );
  }
  if (
    nativeModule().ubrn_uniffi_csca_parser_checksum_func_parse_pem_string() !==
    4767
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_csca_parser_checksum_func_parse_pem_string'
    );
  }
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
});
