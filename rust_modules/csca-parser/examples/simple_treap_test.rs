use csca_parser::{
    build_cert_tree_and_gen_proof, build_cert_tree_root,
};
use hex;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("Testing Treap Tree with hardcoded certificate...");

    // Use a single hardcoded certificate for testing
    let ecdsa_cert_hex = "3082048d30820414a003020102020136300a06082a8648ce3d0403033057310b3009060355040613024c5631243022060355040a0c1b4e6174696f6e616c20536563757269747920417574686f726974793114301206035504030c0b43534341204c6174766961310c300a06035504051303303038301e170d3230303632393133343535395a170d3333303932393133343535395a3057310b3009060355040613024c5631243022060355040a0c1b4e6174696f6e616c20536563757269747920417574686f726974793114301206035504030c0b43534341204c6174766961310c300a06035504051303303038308201b53082014d06072a8648ce3d020130820140020101303c06072a8648ce3d01010231008cb91e82a3386d280f5d6f7e50e641df152f7109ed5456b412b1da197fb71123acd3a729901d1a71874700133107ec53306404307bc382c63d8c150c3c72080ace05afa0c2bea28e4fb22787139165efba91f90f8aa5814a503ad4eb04a8c7dd22ce2826043004a8c7dd22ce28268b39b55416f0447c2fb77de107dcd2a62e880ea53eeb62d57cb4390295dbc9943ab78696fa504c110461041d1c64f068cf45ffa2a63a81b7c13f6b8847a3e77ef14fe3db7fcafe0cbd10e8e826e03436d646aaef87b2e247d4af1e8abe1d7520f9c2a45cb1eb8e95cfd55262b70b29feec5864e19c054ff99129280e4646217791811142820341263c53150231008cb91e82a3386d280f5d6f7e50e641df152f7109ed5456b31f166e6cac0425a7cf3ab6af6b7fc3103b883202e90465650201010362000465f48a6a05d2a1a7f038a0dc909d572023e42e119638e48097436185f6f46b4007ca81ce970d679e41574ad47223e7820d560be7bbda5a7081f729c0f530ec4053f849add568bbf30047515327d264abaf867b35c87d24a1f8ed3dc039138c0aa38201713082016d301f0603551d23041830168014b72748d1e35062f7f6bd5b2df43eb8ccb8601ea030120603551d130101ff040830060101ff020100300d06076781080101060104020500302b0603551d1004243022800f32303230303632393133343535395a810f32303233303632393133343535395a301d0603551d0e04160414b72748d1e35062f7f6bd5b2df43eb8ccb8601ea0302d0603551d1204263024a410300e310c300a06035504070c034c564181106e706b6440706d6c702e676f762e6c76302d0603551d1104263024a410300e310c300a06035504070c034c564181106e706b6440706d6c702e676f762e6c76306d0603551d1f046630643030a02ea02c862a68747470733a2f2f706b64646f776e6c6f6164312e6963616f2e696e742f43524c732f4c56412e63726c3030a02ea02c862a68747470733a2f2f706b64646f776e6c6f6164322e6963616f2e696e742f43524c732f4c56412e63726c300e0603551d0f0101ff040403020106300a06082a8648ce3d040303036700306402300b8c04f6d584f2d9f2bf53bda5c320aad8dc96d9046910351cbfe394e8694615871fa8974dd222c2ec36f62fc9817c290230572c76e18b380480e8aecd677e4a5e13a97eed52b0d59d384fe99201f5f00a25d723a6374ddf53e19bb064e21b1c7b7b";

    let cert_der = hex::decode(ecdsa_cert_hex)?;
    let certificates = vec![cert_der.clone()];

    // Build certificate tree and get root
    match build_cert_tree_root(certificates.clone()) {
        Ok(Some(root)) => {
            println!("Certificate tree root: {}", root);

            // For a single certificate, let's see what we get
            match build_cert_tree_and_gen_proof(certificates.clone(), cert_der.clone()) {
                Ok(proof) => {
                    println!("Inclusion proof generated with {} siblings", proof.len());
                    for (i, sibling) in proof.iter().enumerate() {
                        println!("  Sibling {}: {}", i, sibling);
                    }
                }
                Err(e) => println!("Error generating inclusion proof: {}", e),
            }
        }
        Ok(None) => println!("No certificates to build tree from"),
        Err(e) => println!("Error building certificate tree: {}", e),
    }

    println!("Simple test completed successfully!");
    Ok(())
}
